<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ï†ÑÏûêÏπ†Ìåê - Î∞© ÏÉùÏÑ± + Ïª§ÏÑú</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    #roomSelector {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      background: white; padding: 10px; border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1); z-index: 10;
    }
    #toolbar {
      position: absolute; top: 10px; left: 10px; background: white; padding: 10px;
      border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); z-index: 10;
      display: flex; gap: 10px; align-items: center;
    }
    canvas { border: 1px solid #ccc; display: block; margin: 0 auto; margin-top: 80px; }
    .cursor-label {
      position: absolute;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
    }
    .cursor-dot {
      width: 8px;
      height: 8px;
      background: white;
      border-radius: 50%;
      margin-right: 6px;
    }
  </style>
</head>
<body>
  <div id="roomSelector">
    <input type="text" id="roomInput" placeholder="Î∞© Ïù¥Î¶Ñ" />
    <input type="text" id="userInput" placeholder="ÎãâÎÑ§ÏûÑ" />
    <button id="createBtn">Î∞© ÎßåÎì§Í∏∞</button>
    <button id="joinBtn">ÏûÖÏû•</button>
  </div>

  <div id="toolbar" style="display: none;">
    <label for="color">ÏÉâÏÉÅ:</label>
    <input type="color" id="color" value="#000000" />
    <label for="size">ÍµµÍ∏∞:</label>
    <input type="range" id="size" min="2" max="30" value="8" />
    <button id="eraser">ÏßÄÏö∞Í∞ú</button>
  </div>

  <canvas id="board" width="800" height="600"></canvas>
  <div id="cursor-layer"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();

    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const cursorLayer = document.getElementById('cursor-layer');

    const roomInput = document.getElementById('roomInput');
    const userInput = document.getElementById('userInput');
    const joinBtn = document.getElementById('joinBtn');
    const createBtn = document.getElementById('createBtn');
    const toolbar = document.getElementById('toolbar');
    const colorPicker = document.getElementById('color');
    const sizeSlider = document.getElementById('size');
    const eraserBtn = document.getElementById('eraser');

    let roomId = null;
    let userName = null;
    let isJoined = false;
    let drawing = false;
    let points = [];
    let strokes = [];
    let isEraser = false;
    const cursors = {};
    const cursorTimestamps = {};

    // üõ† Î∞© ÏÉùÏÑ±
    createBtn.addEventListener('click', () => {
      const r = roomInput.value.trim();
      if (!r) return alert('Î∞© Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî');
      socket.emit('create_room', r);
    });

    socket.on('room_created', ({ roomId, created }) => {
      alert(created ? `Î∞© ${roomId} ÏÉùÏÑ±Îê®` : `Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî Î∞©ÏûÖÎãàÎã§`);
    });

    // üö™ Î∞© ÏûÖÏû•
    joinBtn.addEventListener('click', () => {
      const r = roomInput.value.trim();
      const u = userInput.value.trim();
      if (!r || !u) return alert('Î∞© Ïù¥Î¶ÑÍ≥º ÎãâÎÑ§ÏûÑÏùÑ Î™®Îëê ÏûÖÎ†•ÌïòÏÑ∏Ïöî');

      roomId = r;
      userName = u;

      socket.emit('join_room', { roomId, userName });
    });

    socket.on('stroke_sync', (strokeList) => {
      isJoined = true;
      strokes = strokeList;
      redrawCanvas();
      document.getElementById('roomSelector').style.display = 'none';
      toolbar.style.display = 'flex';
    });

    socket.on('object_add', (stroke) => {
      if (!isJoined) return;
      strokes.push(stroke);
      redrawCanvas();
    });

    socket.on('object_delete', (id) => {
      if (!isJoined) return;
      strokes = strokes.filter(s => s.id !== id);
      redrawCanvas();
    });

    socket.on('error', (msg) => alert(msg));
    socket.on('user_joined', ({ userName }) => console.log(`${userName} ÏûÖÏû•`));
    socket.on('user_left', (name) => {
      delete cursors[name];
      delete cursorTimestamps[name];
      renderCursors();
    });

    // Ïª§ÏÑú Ïù¥Îèô
    canvas.addEventListener('pointermove', (e) => {
      if (!isJoined) return;
      socket.emit('cursor_move', {
        roomId,
        userName,
        x: e.clientX,
        y: e.clientY
      });
      if (!drawing || isEraser) return;
      points.push(getPoint(e));
      redrawCanvas();
    });

    socket.on('cursor_update', ({ userName, x, y }) => {
      cursors[userName] = { x, y };
      cursorTimestamps[userName] = Date.now();
      renderCursors();
    });

    setInterval(() => {
      const now = Date.now();
      for (const [name, time] of Object.entries(cursorTimestamps)) {
        if (now - time > 10000) {
          delete cursors[name];
          delete cursorTimestamps[name];
        }
      }
      renderCursors();
    }, 2000);

    canvas.addEventListener('pointerdown', (e) => {
      if (!isJoined) return;
      if (isEraser) {
        const point = getPoint(e);
        const hit = strokes.find(stroke => isPointNearStroke(point, stroke.points));
        if (hit) {
          strokes = strokes.filter(s => s.id !== hit.id);
          socket.emit('object_delete', { roomId, strokeId: hit.id });
          redrawCanvas();
        }
      } else {
        drawing = true;
        points = [getPoint(e)];
      }
    });

    canvas.addEventListener('pointerup', () => {
  if (!isJoined || !drawing) return;
  if (points.length > 1) {
    const stroke = {
      id: crypto.randomUUID(),
      objectType: 'line',
      style: {
        color: colorPicker.value,
        size: parseInt(sizeSlider.value),
      },
      points
    };
    strokes.push(stroke);          // ‚úÖ Î®ºÏ†Ä ÎÇ¥ localÏóê Î∞òÏòÅ
    redrawCanvas();                // ‚úÖ Ï¶âÏãú Îã§Ïãú Í∑∏Î¶¨Í∏∞
    socket.emit('object_add', { roomId, stroke }); // ÏÑúÎ≤ÑÏóêÎèÑ Ï†ÑÏÜ°
  }
  drawing = false;
  points = [];
});

    eraserBtn.addEventListener('click', () => isEraser = true);
    colorPicker.addEventListener('change', () => isEraser = false);
    sizeSlider.addEventListener('input', () => isEraser = false);

    function getPoint(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top,
        pressure: e.pressure || 0.5
      };
    }

    function isPointNearStroke(point, strokePoints, threshold = 10) {
      return strokePoints.some(p => {
        const dx = p.x - point.x;
        const dy = p.y - point.y;
        return Math.sqrt(dx * dx + dy * dy) < threshold;
      });
    }

    function drawStroke(rawPoints, color, style) {
      const strokePoints = rawPoints.map(p => [p.x, p.y, p.pressure]);
      const outline = getStroke(strokePoints, style);

      if (outline.length < 1) return;

      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(outline[0][0], outline[0][1]);
      for (let i = 1; i < outline.length; i++) {
        ctx.lineTo(outline[i][0], outline[i][1]);
      }
      ctx.closePath();
      ctx.fill();
  }


    function redrawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Î™®Îì† Í∏∞Ï°¥ stroke
      for (const stroke of strokes) {
        drawStroke(stroke.points, stroke.style.color, stroke.style);
      }

      // ‚ú® ÌòÑÏû¨ ÏßÑÌñâ Ï§ëÏù∏ stroke ÌîÑÎ¶¨Î∑∞ (drawing Ï§ëÏùº Îïå)
      if (drawing && points.length > 0 && !isEraser) {
        const previewStyle = {
          color: colorPicker.value,
          size: parseInt(sizeSlider.value),
          thinning: 0.5,
          smoothing: 0.5,
          taperStart: 0,
          taperEnd: 0
        };
        drawStroke(points, previewStyle.color, previewStyle);
      }
    }


    function renderCursors() {
      cursorLayer.innerHTML = '';
      for (const [name, pos] of Object.entries(cursors)) {
        if (name === userName) continue;
        const el = document.createElement('div');
        el.className = 'cursor-label';
        el.style.left = pos.x + 'px';
        el.style.top = pos.y + 'px';
        el.innerHTML = `<div class="cursor-dot"></div>${name}`;
        cursorLayer.appendChild(el);
      }
    }
  </script>
</body>
</html>
<!-- build: 2025-04-12 23:45 -->